<?xml version="1.0" encoding="utf-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-US" target-language="zh-Hant" original="MICROSOFT.VISUALSTUDIO.THREADING.ANALYZERS/STRINGS.RESX" tool-id="MultilingualAppToolkit" product-name="n/a" product-version="n/a" build-num="n/a">
    <header>
      <tool tool-id="MultilingualAppToolkit" tool-name="Multilingual App Toolkit" tool-version="4.0.1795.0" tool-company="Microsoft" />
    </header>
    <body>
      <group id="MICROSOFT.VISUALSTUDIO.THREADING.ANALYZERS/STRINGS.RESX" datatype="resx">
        <trans-unit id="AwaitXInstead" translate="yes" xml:space="preserve">
          <source>Await {0} instead</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">而等待 {0}</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.
{0} is a method name.</note>
        </trans-unit>
        <trans-unit id="UseAwaitInstead" translate="yes" xml:space="preserve">
          <source>Use await instead</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">使用等待相反</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD001_MessageFormat" translate="yes" xml:space="preserve">
          <source>Synchronously waiting on tasks or awaiters may cause deadlocks. Use JoinableTaskFactory.Run instead.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">在任務或等待程式同步等待是危險的可能會導致鎖死。請考慮以下選項︰ 1) 切換到非同步等待來電者是否已經"async"方法。2） 鏈的調用方，並將"async"方法，然後更改此代碼是非同步等待的變化。3） 使用 JoinableTaskFactory.Run() 來伺候的任務或等待程式。請參閱 HTTP://blogs.msdn.com/b/andrewarnottms/archive/2014/05/07/asynchronous-and-multithreaded-programming-within-vs-using-the-joinabletaskfactory.aspx 更多的資訊。</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD001_Title" translate="yes" xml:space="preserve">
          <source>Avoid problematic synchronous waits</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">在任務或等待程式同步等待是危險的可能會導致鎖死。</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD002_MessageFormat" translate="yes" xml:space="preserve">
          <source>Visual Studio service "{0}" should be used on main thread explicitly. 
Call ThreadHelper.ThrowIfNotOnUIThread() or await JoinableTaskFactory.SwitchToMainThreadAsync() first.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">視覺工作室服務"{0}"應明確在主執行緒上使用。
請或者驗證當前執行緒是主執行緒，或者切換到主執行緒以非同步方式。
1) Api 來驗證當前執行緒是主執行緒︰ ThreadHelper.ThrowIfNotOnUIThread() 或 IThreadHandling.VerifyOnUIThread()。
2) Api 來切換到主執行緒以非同步方式︰ JoinableTaskFactory.SwitchToMainThreadAsync() 或 IThreadHandling.SwitchToUIThread()。對 HTTP://blogs.msdn.com/b/andrewarnottms/archive/2014/05/07/asynchronous-and-multithreaded-programming-within-vs-using-the-joinabletaskfactory.aspx 的更多資訊請參閱
。</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD002_Title" translate="yes" xml:space="preserve">
          <source>Use VS services from UI thread</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">視覺工作室服務應明確在主執行緒上使用。</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD003_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid "async void" methods, because any exceptions not handled by the method will crash the process.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">避免非同步 Void 方法，因為從非同步 void 方法引發的任何異常將直接在 SynchronizationCoNtext 上提出，將會使進程崩潰。對 HTTPs://msdn.microsoft.com/en-us/magazine/jj991977.aspx 的更多資訊請參閱
。</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
          <note from="MultilingualBuild" annotates="source" priority="2">"async void" is a pair of C# keywords. Do not translate them.</note>
        </trans-unit>
        <trans-unit id="VSTHRD003_Title" translate="yes" xml:space="preserve">
          <source>Avoid async void methods</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">避免非同步 Void 方法。</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
          <note from="MultilingualBuild" annotates="source" priority="2">"async void" is a pair of C# keywords. Do not translate them.</note>
        </trans-unit>
        <trans-unit id="VSTHRD004_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid using async lambda for a void returning delegate type, because any exceptions not handled by the delegate will crash the process.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">避免使用非同步 lambda 作為 void 返回委託類型，因為從返回 void 非同步 lambda 引發的任何異常將直接在 SynchronizationCoNtext 上提出，將會使進程崩潰。對 HTTPs://msdn.microsoft.com/en-us/magazine/jj991977.aspx 的更多資訊請參閱
。</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
          <note from="MultilingualBuild" annotates="source" priority="2">"void" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD004_Title" translate="yes" xml:space="preserve">
          <source>Avoid unsupported async delegates</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">非同步 lambda 是被用作 void 返回委託類型。</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD005_MessageFormat" translate="yes" xml:space="preserve">
          <source>AsyncEventHandler delegates should be invoked via the extension method "TplExtensions.InvokeAsync()" defined in Microsoft.VisualStudio.Threading assembly.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">AsyncEventHandler 代表應該通過"TplExtensions.InvokeAsync()"Microsoft.VisualStudio.Threading 程式集中定義的擴充方法調用。</target>
        </trans-unit>
        <trans-unit id="VSTHRD005_Title" translate="yes" xml:space="preserve">
          <source>Use InvokeAsync to raise async events</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">AsyncEventHandler 代表應該通過"TplExtensions.InvokeAsync()"Microsoft.VisualStudio.Threading 程式集中定義的擴充方法調用。</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD006_MessageFormat" translate="yes" xml:space="preserve">
          <source>Calling await on a Task inside a JoinableTaskFactory.Run, when the task is initialized outside the delegate can cause potential deadlocks.
You can avoid this problem by ensuring the task is initialized within the delegate or by using JoinableTask instead of Task.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">呼叫等待任務裡面的 JoinableTaskFactory.Run，這項任務委託外面的初始化時可能導致潛在的鎖死。
通過確保任務初始化委託內或通過使用 JoinableTask 而不任務，你可以避免此問題。</target>
        </trans-unit>
        <trans-unit id="VSTHRD006_Title" translate="yes" xml:space="preserve">
          <source>Avoid awaiting non-joinable tasks in join contexts</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">避免調用內"JoinableTaskFactory.Run"委託等待任務，當任務定義之外的委託，以避免潛在的鎖死。</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD007_MessageFormat" translate="yes" xml:space="preserve">
          <source>Lazy&lt;Task&lt;T&gt;&gt;.Value can deadlock.
Use AsyncLazy&lt;T&gt; instead.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">調用懶&lt;Task&lt;T&gt;&gt;。值工廠以前啟動時，值會出現鎖死。您應改用 AsyncLazy&lt;T&gt; 
。</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD007_Title" translate="yes" xml:space="preserve">
          <source>Avoid using Lazy<it id="1" pos="open">&lt;T&gt;</it> where T is a Task<it id="2" pos="open">&lt;T2&gt;</it></source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">避免使用懶<it id="1" pos="open">&lt;T&gt;</it>其中 T 一項任務。</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD008_MessageFormat" translate="yes" xml:space="preserve">
          <source>{0} synchronously blocks. Await {1} instead.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">{0} 成員同步塊。改用 {1} 並等待其結果。</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD008_MessageFormat_UseAwaitInstead" translate="yes" xml:space="preserve">
          <source>{0} synchronously blocks. Use await instead.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">{0} 成員同步塊。使用等待相反。</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD008_Title" translate="yes" xml:space="preserve">
          <source>Call async methods when in an async method</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">可等待的替代品時非同步方法調用</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD009_MessageFormat" translate="yes" xml:space="preserve">
          <source>Limit use of synchronously blocking method calls such as JoinableTaskFactory.Run or Task.Result to public entrypoint members where you must be synchronous. Using it for internal members can needlessly add synchronous frames between asynchronous frames, leading to threadpool exhaustion.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">限制使用的同步阻塞如 JoinableTaskFactory.Run 或 Task.Result 各位公共進入點，在那裡你必須同步的方法調用。它為內部成員可以使用不必要添加同步幀之間非同步幀，導致執行緒池用盡。</target>
        </trans-unit>
        <trans-unit id="VSTHRD009_Title" translate="yes" xml:space="preserve">
          <source>Implement internal logic asynchronously</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">避免使用同步塊中的非公共方法。</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD010_CodeFix_Title" translate="yes" xml:space="preserve">
          <source>Rename to {0}</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">重命名為 {0}。</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
          <note from="MultilingualBuild" annotates="source" priority="2">{0} is a method name.</note>
        </trans-unit>
        <trans-unit id="VSTHRD010_MessageFormat" translate="yes" xml:space="preserve">
          <source>Use "Async" suffix in names of Task-returning methods.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">在任務返回方法名稱中使用"Async"尾碼。</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD010_Title" translate="yes" xml:space="preserve">
          <source>Use "Async" suffix for async methods</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">在任務返回方法名稱中使用"Async"尾碼。</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD011_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid method overloads that assume TaskScheduler.Current. Use an overload that accepts a TaskScheduler and specify TaskScheduler.Default (or any other) explicitly.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">避免假設 TaskScheduler.Current 的方法重載。使用接受 TaskScheduler 重載和顯式指定 TaskScheduler.Default （或任何其他）。</target>
        </trans-unit>
        <trans-unit id="VSTHRD011_Title" translate="yes" xml:space="preserve">
          <source>Avoid method overloads that assume TaskScheduler.Current</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">避免方法重載假定 TaskScheduler.Current</target>
        </trans-unit>
        <trans-unit id="VSTHRD003_CodeFix_Title" translate="yes" xml:space="preserve">
          <source>Change return type to Task</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">返回類型改變為任務</target>
          <note from="MultilingualBuild" annotates="source" priority="2">Task is a type name and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD012_MessageFormat" translate="yes" xml:space="preserve">
          <source>Provide an instance of JoinableTaskFactory in this call (or another overload) to avoid deadlocks with the main thread.</source>
          <target state="new">Provide an instance of JoinableTaskFactory in this call (or another overload) to avoid deadlocks with the main thread.</target>
        </trans-unit>
        <trans-unit id="VSTHRD012_Title" translate="yes" xml:space="preserve">
          <source>Provide JoinableTaskFactory where allowed</source>
          <target state="new">Provide JoinableTaskFactory where allowed</target>
        </trans-unit>
        <trans-unit id="VSTHRD013_MessageFormat" translate="yes" xml:space="preserve">
          <source>Expose an async version of this method that does not synchronously block. Then simplify this method to call that async method within a JoinableTaskFactory.Run delegate.</source>
          <target state="new">Expose an async version of this method that does not synchronously block. Then simplify this method to call that async method within a JoinableTaskFactory.Run delegate.</target>
        </trans-unit>
        <trans-unit id="VSTHRD013_Title" translate="yes" xml:space="preserve">
          <source>Offer async methods</source>
          <target state="new">Offer async methods</target>
        </trans-unit>
        <trans-unit id="VSTHRD014_MessageFormat" translate="yes" xml:space="preserve">
          <source>Await JoinableTaskFactory.SwitchToMainThreadAsync() to switch to the UI thread instead of APIs that can deadlock or require specifying a priority.</source>
          <target state="new">Await JoinableTaskFactory.SwitchToMainThreadAsync() to switch to the UI thread instead of APIs that can deadlock or require specifying a priority.</target>
        </trans-unit>
        <trans-unit id="VSTHRD014_Title" translate="yes" xml:space="preserve">
          <source>Avoid legacy threading switching APIs</source>
          <target state="new">Avoid legacy threading switching APIs</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>