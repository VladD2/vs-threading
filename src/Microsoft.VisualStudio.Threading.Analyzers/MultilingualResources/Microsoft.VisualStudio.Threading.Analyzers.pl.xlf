<?xml version="1.0" encoding="utf-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-US" target-language="pl" original="MICROSOFT.VISUALSTUDIO.THREADING.ANALYZERS/STRINGS.RESX" tool-id="MultilingualAppToolkit" product-name="n/a" product-version="n/a" build-num="n/a">
    <header>
      <tool tool-id="MultilingualAppToolkit" tool-name="Multilingual App Toolkit" tool-version="4.0.1795.0" tool-company="Microsoft" />
    </header>
    <body>
      <group id="MICROSOFT.VISUALSTUDIO.THREADING.ANALYZERS/STRINGS.RESX" datatype="resx">
        <trans-unit id="AwaitXInstead" translate="yes" xml:space="preserve">
          <source>Await {0} instead</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Zamiast czekać na {0}</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.
{0} is a method name.</note>
        </trans-unit>
        <trans-unit id="UseAwaitInstead" translate="yes" xml:space="preserve">
          <source>Use await instead</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Zamiast tego czekają na użycie</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD001_MessageFormat" translate="yes" xml:space="preserve">
          <source>Synchronously waiting on tasks or awaiters may cause deadlocks. Use JoinableTaskFactory.Run instead.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Synchroniczne oczekiwanie na zadania lub awaiters jest niebezpieczne i może powodować blokad martwe. Proszę rozważyć następujące opcje: 1) Przełącz się do asynchronicznego oczekiwania, jeśli obiekt wywołujący jest już metodą "async". (2) zmiana łańcucha wywołań metod "async", a następnie zmienić ten kod, aby być asynchroniczne await. (3) stosowanie JoinableTaskFactory.Run() czekać na zadania lub awaiters. Odnoszą się do http://blogs.msdn.com/b/andrewarnottms/archive/2014/05/07/asynchronous-and-multithreaded-programming-within-vs-using-the-joinabletaskfactory.aspx Aby uzyskać więcej informacji.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD001_Title" translate="yes" xml:space="preserve">
          <source>Avoid problematic synchronous waits</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Synchroniczne oczekiwanie na zadania lub awaiters jest niebezpieczne i może powodować blokad martwe.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD002_MessageFormat" translate="yes" xml:space="preserve">
          <source>Visual Studio service "{0}" should be used on main thread explicitly. 
Call ThreadHelper.ThrowIfNotOnUIThread() or await JoinableTaskFactory.SwitchToMainThreadAsync() first.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Visual Studio usługi "{0}", należy jawnie w głównym wątku. 
Albo Sprawdź bieżący wątek jest głównym wątku, lub przełączenie wątku głównego asynchronicznie. 
1) interfejsów API, aby sprawdzić bieżący wątek jest wątek główny: ThreadHelper.ThrowIfNotOnUIThread(), lub IThreadHandling.VerifyOnUIThread(). 
2) interfejsów API, aby przełączyć się do głównego wątku asynchronicznie: JoinableTaskFactory.SwitchToMainThreadAsync() lub IThreadHandling.SwitchToUIThread(). 
Się do http://blogs.msdn.com/b/andrewarnottms/archive/2014/05/07/asynchronous-and-multithreaded-programming-within-vs-using-the-joinabletaskfactory.aspx Aby uzyskać więcej informacji.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD002_Title" translate="yes" xml:space="preserve">
          <source>Use VS services from UI thread</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Usługi Visual Studio, należy jawnie w głównym wątku.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD003_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid "async void" methods, because any exceptions not handled by the method will crash the process.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Metoda Async Void, należy unikać, ponieważ wszystkie wyjątki, wygenerowany z metody asynchronicznej nieważne będzie uruchamiany bezpośrednio na SynchronizationContext i nastąpi awaria procesu. 
Się do https://msdn.microsoft.com/en-us/magazine/jj991977.aspx Aby uzyskać więcej informacji.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
          <note from="MultilingualBuild" annotates="source" priority="2">"async void" is a pair of C# keywords. Do not translate them.</note>
        </trans-unit>
        <trans-unit id="VSTHRD003_Title" translate="yes" xml:space="preserve">
          <source>Avoid async void methods</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Uniknąć Metoda Async Void.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
          <note from="MultilingualBuild" annotates="source" priority="2">"async void" is a pair of C# keywords. Do not translate them.</note>
        </trans-unit>
        <trans-unit id="VSTHRD004_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid using async lambda for a void returning delegate type, because any exceptions not handled by the delegate will crash the process.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Unikaj używania async lambda jako void zwracanie typu delegata, ponieważ wszystkie wyjątki, wygenerowany z lambda async zwracające void będzie uruchamiany bezpośrednio na SynchronizationContext i nastąpi awaria procesu. 
Się do https://msdn.microsoft.com/en-us/magazine/jj991977.aspx Aby uzyskać więcej informacji.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
          <note from="MultilingualBuild" annotates="source" priority="2">"void" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD004_Title" translate="yes" xml:space="preserve">
          <source>Avoid unsupported async delegates</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Async lambda jest używana jako void zwracanie typu delegata.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD005_MessageFormat" translate="yes" xml:space="preserve">
          <source>AsyncEventHandler delegates should be invoked via the extension method "TplExtensions.InvokeAsync()" defined in Microsoft.VisualStudio.Threading assembly.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">AsyncEventHandler delegatów powinien być wywoływane za pośrednictwem metody rozszerzenia, które "TplExtensions.InvokeAsync()" zdefiniowany w zestawie Microsoft.VisualStudio.Threading.</target>
        </trans-unit>
        <trans-unit id="VSTHRD005_Title" translate="yes" xml:space="preserve">
          <source>Use InvokeAsync to raise async events</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">AsyncEventHandler delegatów powinien być wywoływane za pośrednictwem metody rozszerzenia, które "TplExtensions.InvokeAsync()" zdefiniowany w zestawie Microsoft.VisualStudio.Threading.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD006_MessageFormat" translate="yes" xml:space="preserve">
          <source>Calling await on a Task inside a JoinableTaskFactory.Run, when the task is initialized outside the delegate can cause potential deadlocks.
You can avoid this problem by ensuring the task is initialized within the delegate or by using JoinableTask instead of Task.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Powołanie czekają na zadanie wewnątrz JoinableTaskFactory.Run, kiedy zadanie jest inicjowany poza pełnomocnik może powodować potencjalnego zakleszczenia. Można uniknąć tego problemu, zapewniając, że zadanie jest zainicjowany w ramach pełnomocnika lub za pomocą JoinableTask zamiast 
.</target>
        </trans-unit>
        <trans-unit id="VSTHRD006_Title" translate="yes" xml:space="preserve">
          <source>Avoid awaiting non-joinable tasks in join contexts</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Należy unikać telefonicznej czekają na zadanie wewnątrz delegować "JoinableTaskFactory.Run", gdy zadanie jest zdefiniowana poza delegata, aby uniknąć potencjalnego zakleszczenia.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD007_MessageFormat" translate="yes" xml:space="preserve">
          <source>Lazy&lt;Task&lt;T&gt;&gt;.Value can deadlock.
Use AsyncLazy&lt;T&gt; instead.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Wywołanie leniwy&lt;Task&lt;T&gt;&gt;. Wartość można zakleszczenie, gdy wcześniej została uruchomiona fabryka wartość. Zamiast tego należy użyć AsyncLazy&lt;T&gt; 
.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD007_Title" translate="yes" xml:space="preserve">
          <source>Avoid using Lazy<it id="1" pos="open">&lt;T&gt;</it> where T is a Task<it id="2" pos="open">&lt;T2&gt;</it></source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Należy unikać używania Lazy<it id="1" pos="open"> &lt;T&gt; </it> , gdzie T jest zadanie.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD008_MessageFormat" translate="yes" xml:space="preserve">
          <source>{0} synchronously blocks. Await {1} instead.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Członkowskie {0}, blokuje synchronicznie. Zamiast tego wywołania {1} i czekać na jej wynik.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD008_MessageFormat_UseAwaitInstead" translate="yes" xml:space="preserve">
          <source>{0} synchronously blocks. Use await instead.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Członkowskie {0}, blokuje synchronicznie. Użycie await zamiast.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD008_Title" translate="yes" xml:space="preserve">
          <source>Call async methods when in an async method</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Wywołanie awaitable alternatywy w metodę komunikacji asynchronicznej.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD009_MessageFormat" translate="yes" xml:space="preserve">
          <source>Limit use of synchronously blocking method calls such as JoinableTaskFactory.Run or Task.Result to public entrypoint members where you must be synchronous. Using it for internal members can needlessly add synchronous frames between asynchronous frames, leading to threadpool exhaustion.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Wykorzystanie limitu blokowanie synchronicznie wywołania metody takie jak JoinableTaskFactory.Run lub Task.Result do członków publicznych entrypoint gdzie musi być synchroniczne. Używając go do wewnętrznego członków niepotrzebnie można dodać synchroniczne klatek między asynchronicznych, co prowadzi do wyczerpania puli wątków.</target>
        </trans-unit>
        <trans-unit id="VSTHRD009_Title" translate="yes" xml:space="preserve">
          <source>Implement internal logic asynchronously</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Uniknąć synchronicznego bloki w metody niepublicznej.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD010_CodeFix_Title" translate="yes" xml:space="preserve">
          <source>Rename to {0}</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Zmień nazwę na {0}.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
          <note from="MultilingualBuild" annotates="source" priority="2">{0} is a method name.</note>
        </trans-unit>
        <trans-unit id="VSTHRD010_MessageFormat" translate="yes" xml:space="preserve">
          <source>Use "Async" suffix in names of Task-returning methods.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">W nazwach Metoda przekazujących dane zadanie, należy użyć sufiksem "Async".</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD010_Title" translate="yes" xml:space="preserve">
          <source>Use "Async" suffix for async methods</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">W nazwach Metoda przekazujących dane zadanie, należy użyć sufiksem "Async".</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD011_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid method overloads that assume TaskScheduler.Current. Use an overload that accepts a TaskScheduler and specify TaskScheduler.Default (or any other) explicitly.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Uniknąć przeciążenia metody, które zakładają TaskScheduler.Current. Użyj Przeciążenie akceptującym TaskScheduler i jawnie określić TaskScheduler.Default (lub innych).</target>
        </trans-unit>
        <trans-unit id="VSTHRD011_Title" translate="yes" xml:space="preserve">
          <source>Avoid method overloads that assume TaskScheduler.Current</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Uniknąć przeciążenia metody, które zakładają TaskScheduler.Current</target>
        </trans-unit>
        <trans-unit id="VSTHRD003_CodeFix_Title" translate="yes" xml:space="preserve">
          <source>Change return type to Task</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Zmień typ zwrotny do zadań</target>
          <note from="MultilingualBuild" annotates="source" priority="2">Task is a type name and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD012_MessageFormat" translate="yes" xml:space="preserve">
          <source>Provide an instance of JoinableTaskFactory in this call (or another overload) to avoid deadlocks with the main thread.</source>
          <target state="new">Provide an instance of JoinableTaskFactory in this call (or another overload) to avoid deadlocks with the main thread.</target>
        </trans-unit>
        <trans-unit id="VSTHRD012_Title" translate="yes" xml:space="preserve">
          <source>Provide JoinableTaskFactory where allowed</source>
          <target state="new">Provide JoinableTaskFactory where allowed</target>
        </trans-unit>
        <trans-unit id="VSTHRD013_MessageFormat" translate="yes" xml:space="preserve">
          <source>Expose an async version of this method that does not synchronously block. Then simplify this method to call that async method within a JoinableTaskFactory.Run delegate.</source>
          <target state="new">Expose an async version of this method that does not synchronously block. Then simplify this method to call that async method within a JoinableTaskFactory.Run delegate.</target>
        </trans-unit>
        <trans-unit id="VSTHRD013_Title" translate="yes" xml:space="preserve">
          <source>Offer async methods</source>
          <target state="new">Offer async methods</target>
        </trans-unit>
        <trans-unit id="VSTHRD014_MessageFormat" translate="yes" xml:space="preserve">
          <source>Await JoinableTaskFactory.SwitchToMainThreadAsync() to switch to the UI thread instead of APIs that can deadlock or require specifying a priority.</source>
          <target state="new">Await JoinableTaskFactory.SwitchToMainThreadAsync() to switch to the UI thread instead of APIs that can deadlock or require specifying a priority.</target>
        </trans-unit>
        <trans-unit id="VSTHRD014_Title" translate="yes" xml:space="preserve">
          <source>Avoid legacy threading switching APIs</source>
          <target state="new">Avoid legacy threading switching APIs</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>