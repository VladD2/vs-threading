<?xml version="1.0" encoding="utf-8"?>
<root>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AwaitXInstead" xml:space="preserve">
    <value>Вместо этого ждать {0}</value>
    <comment>"await" is a C# keyword and should not be translated.
{0} is a method name.</comment>
  </data>
  <data name="UseAwaitInstead" xml:space="preserve">
    <value>Используйте вместо этого ждут</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD001_MessageFormat" xml:space="preserve">
    <value>Синхронное ожидание задач или ждущие является опасным и может привести к врезные замки. Пожалуйста, рассмотрите следующие варианты: 1) переключиться на асинхронное ожидание, если вызывающий метод «async». 2) изменить цепочку вызывающих объектов, чтобы быть «async» методы, а затем измените этот код для асинхронной ждать. 3) использование JoinableTaskFactory.Run() для ожидания задач или ждущие. Обратитесь к http://blogs.msdn.com/b/andrewarnottms/archive/2014/05/07/asynchronous-and-multithreaded-programming-within-vs-using-the-joinabletaskfactory.aspx для получения дополнительной информации.</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD001_Title" xml:space="preserve">
    <value>Синхронное ожидание задач или ждущие является опасным и может привести к врезные замки.</value>
  </data>
  <data name="VSTHRD002_MessageFormat" xml:space="preserve">
    <value>Visual Studio Служба «{0}» должен использоваться на основном потоке явным образом. 
Пожалуйста, либо Проверьте текущий поток является основной поток или переключиться на основной поток асинхронно. 
1) API для проверки текущего потока является основной поток: ThreadHelper.ThrowIfNotOnUIThread() или IThreadHandling.VerifyOnUIThread(). 
2) API, чтобы переключиться на основной поток асинхронно: JoinableTaskFactory.SwitchToMainThreadAsync() или IThreadHandling.SwitchToUIThread(). 
Обратитесь к http://blogs.msdn.com/b/andrewarnottms/archive/2014/05/07/asynchronous-and-multithreaded-programming-within-vs-using-the-joinabletaskfactory.aspx для получения дополнительной информации.</value>
  </data>
  <data name="VSTHRD002_Title" xml:space="preserve">
    <value>Visual Studio Служба должна использоваться на основном потоке явным образом.</value>
  </data>
  <data name="VSTHRD003_MessageFormat" xml:space="preserve">
    <value>Избегайте метода Async Void, потому что любые исключения из асинхронного метода void будет поднят на SynchronizationContext и приведет к краху процесса. 
Обратитесь к https://msdn.microsoft.com/en-us/magazine/jj991977.aspx для получения дополнительной информации.</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD003_Title" xml:space="preserve">
    <value>Избегайте метод Async Void.</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD004_MessageFormat" xml:space="preserve">
    <value>Избегайте использования async лямбда как void возвращаемый тип делегата, поскольку любые исключения из async лямбда, возвращая значение void, будет непосредственно на SynchronizationContext и приведет к краху процесса. 
Обратитесь к https://msdn.microsoft.com/en-us/magazine/jj991977.aspx для получения дополнительной информации.</value>
    <comment>"void" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD004_Title" xml:space="preserve">
    <value>Async лямбда используется как void возвращаемый тип делегата.</value>
  </data>
  <data name="VSTHRD005_MessageFormat" xml:space="preserve">
    <value>AsyncEventHandler делегатов следует ссылаться через метод расширения, который «TplExtensions.InvokeAsync()» определен в сборке Microsoft.VisualStudio.Threading.</value>
  </data>
  <data name="VSTHRD005_Title" xml:space="preserve">
    <value>AsyncEventHandler делегатов следует ссылаться через метод расширения, который «TplExtensions.InvokeAsync()» определен в сборке Microsoft.VisualStudio.Threading.</value>
  </data>
  <data name="VSTHRD006_MessageFormat" xml:space="preserve">
    <value>Вызов ожидают задачи внутри JoinableTaskFactory.Run при инициализации задачи за пределами делегата может привести к потенциальной взаимоблокировки. 
, Вы можете избежать этой проблемы путем обеспечения задачи инициализации делегата или с помощью JoinableTask вместо задачи.</value>
  </data>
  <data name="VSTHRD006_Title" xml:space="preserve">
    <value>Избегайте вызова ожидают задачи внутри делегата «JoinableTaskFactory.Run», когда задача определяется за пределами делегата, избежать потенциальных взаимоблокировок.</value>
  </data>
  <data name="VSTHRD007_MessageFormat" xml:space="preserve">
    <value>Вызов Lazy&lt;Task&lt;T&gt;&gt;. Значение может взаимоблокироваться при значение фабрики ранее было начато. 
, Вместо этого следует использовать AsyncLazy&lt;T&gt; .</value>
  </data>
  <data name="VSTHRD007_Title" xml:space="preserve">
    <value>Избегайте использования Lazy &lt;T&gt;  , где T является задачей.</value>
  </data>
  <data name="VSTHRD008_MessageFormat" xml:space="preserve">
    <value>Член {0} синхронно блоков. Вместо этого вызовите {1} и дождаться его результатов.</value>
  </data>
  <data name="VSTHRD008_MessageFormat_UseAwaitInstead" xml:space="preserve">
    <value>Член {0} синхронно блоков. Используйте вместо этого ждут.</value>
  </data>
  <data name="VSTHRD008_Title" xml:space="preserve">
    <value>Вызовите awaitable альтернативы, когда в методе async.</value>
  </data>
  <data name="VSTHRD009_MessageFormat" xml:space="preserve">
    <value>Ограничение использования синхронно блокировки вызовов метода например JoinableTaskFactory.Run или Task.Result общественного entrypoint членов, где вы должны быть синхронным. Используя для внутренних членов needlessly можно добавить синхронные кадры между асинхронным кадрами, приводит к истощению threadpool.</value>
  </data>
  <data name="VSTHRD009_Title" xml:space="preserve">
    <value>Избегайте синхронных блоков методов, не являющихся открытыми.</value>
  </data>
  <data name="VSTHRD010_CodeFix_Title" xml:space="preserve">
    <value>Переименуйте {0}.</value>
    <comment>{0} is a method name.</comment>
  </data>
  <data name="VSTHRD010_MessageFormat" xml:space="preserve">
    <value>Используйте суффикс «Async» в задаче возвращения имен методов.</value>
  </data>
  <data name="VSTHRD010_Title" xml:space="preserve">
    <value>Используйте суффикс «Async» в задаче возвращения имен методов.</value>
  </data>
  <data name="VSTHRD003_CodeFix_Title" xml:space="preserve">
    <value>Изменение возвращаемого типа к задаче</value>
    <comment>Task is a type name and should not be translated.</comment>
  </data>
  <data name="VSTHRD011_MessageFormat" xml:space="preserve">
    <value>Избегайте перегрузки метода, которые предполагают TaskScheduler.Current. Используйте перегрузку, которая принимает TaskScheduler и явно указать TaskScheduler.Default (или любой другой).</value>
  </data>
  <data name="VSTHRD011_Title" xml:space="preserve">
    <value>Избегайте перегрузки метода, которые предполагают TaskScheduler.Current</value>
  </data>
</root>