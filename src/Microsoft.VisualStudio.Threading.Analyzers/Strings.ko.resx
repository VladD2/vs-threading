<?xml version="1.0" encoding="utf-8"?>
<root>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AwaitXInstead" xml:space="preserve">
    <value>{0}를 대신 기다리고 있습니다</value>
    <comment>"await" is a C# keyword and should not be translated.
{0} is a method name.</comment>
  </data>
  <data name="UseAwaitInstead" xml:space="preserve">
    <value>사용 대신 기다리고 있습니다.</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD001_MessageFormat" xml:space="preserve">
    <value>동기적으로 작업 또는 awaiters에 기다리는 교착 상태가 발생할 수 있습니다. 대신 JoinableTaskFactory.Run를 사용 합니다.</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD001_Title" xml:space="preserve">
    <value>문제가 동기 대기 방지</value>
  </data>
  <data name="VSTHRD002_MessageFormat" xml:space="preserve">
    <value>Visual Studio 서비스 "{0}"은 명시적으로 주 스레드에서 사용 되어야 한다. 
전화 ThreadHelper.ThrowIfNotOnUIThread() 또는 JoinableTaskFactory.SwitchToMainThreadAsync()를 먼저 기다리고 있습니다.</value>
  </data>
  <data name="VSTHRD002_Title" xml:space="preserve">
    <value>UI 스레드에서 서비스를 사용 하 여 대</value>
  </data>
  <data name="VSTHRD003_CodeFix_Title" xml:space="preserve">
    <value>변경 작업에 반환 형식</value>
    <comment>Task is a type name and should not be translated.</comment>
  </data>
  <data name="VSTHRD003_MessageFormat" xml:space="preserve">
    <value>메서드에 의해 처리 되지 않은 예외는 프로세스 충돌 때문에 "async"가 void 메서드를 하지 마십시오.</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD003_Title" xml:space="preserve">
    <value>비동기 void 메서드를 방지</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD004_MessageFormat" xml:space="preserve">
    <value>대리자에 의해 처리 되지 않은 예외는 프로세스 충돌 때문에 void 반환 대리자 형식에 대 한 비동기 람다를 사용 하지 마십시오.</value>
    <comment>"void" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD004_Title" xml:space="preserve">
    <value>지원 되지 않는 비동기 대리자를 방지</value>
  </data>
  <data name="VSTHRD005_MessageFormat" xml:space="preserve">
    <value>AsyncEventHandler 대리자는 "TplExtensions.InvokeAsync()" Microsoft.VisualStudio.Threading 어셈블리에 정의 된 확장 메서드를 통해 호출 해야 합니다.</value>
  </data>
  <data name="VSTHRD005_Title" xml:space="preserve">
    <value>InvokeAsync 비동기 이벤트를 사용 하 여</value>
  </data>
  <data name="VSTHRD006_MessageFormat" xml:space="preserve">
    <value>전화 JoinableTaskFactory.Run, 내부 작업에 기다리고 대리자 외부 작업 초기화 때 잠재적인 교착 상태를 일으킬 수 있습니다. 작업을 함으로써이 문제를 피할 수 있습니다 
대리자 또는 작업 대신 JoinableTask를 사용 하 여 초기화 됩니다.</value>
  </data>
  <data name="VSTHRD006_Title" xml:space="preserve">
    <value>조인 상황에서 비 결합 작업을 대기 하지 마십시오</value>
  </data>
  <data name="VSTHRD007_MessageFormat" xml:space="preserve">
    <value>게으른&lt;Task&lt;T&gt;&gt;입니다. 값 교착 상태 수 있습니다. 
사용 AsyncLazy&lt;T&gt; 대신.</value>
  </data>
  <data name="VSTHRD007_Title" xml:space="preserve">
    <value>게으른 &lt;T&gt;  T 작업 &lt;T2&gt;  는 사용 하지 마십시오</value>
  </data>
  <data name="VSTHRD008_MessageFormat" xml:space="preserve">
    <value>{0} 동기적으로 차단합니다. 대신 {1}를 기다리고 있습니다.</value>
  </data>
  <data name="VSTHRD008_MessageFormat_UseAwaitInstead" xml:space="preserve">
    <value>{0} 동기적으로 차단합니다. 사용 대신 기다리고 있습니다.</value>
  </data>
  <data name="VSTHRD008_Title" xml:space="preserve">
    <value>비동기 메서드에서 비동기 메서드 호출</value>
  </data>
  <data name="VSTHRD009_MessageFormat" xml:space="preserve">
    <value>제한 사용 동기적으로 공용 진입점 회원 동기 해야 어디에 JoinableTaskFactory.Run 또는 Task.Result 같은 메서드 호출을 차단 합니다. 내부 구성원에 대 한 그것을 사용 하 여 불필요 하 게 비동기 프레임, threadpool 고갈으로 이어지는 사이 동기 프레임을 추가할 수 있습니다.</value>
  </data>
  <data name="VSTHRD009_Title" xml:space="preserve">
    <value>비동기적으로 내부 논리를 구현</value>
  </data>
  <data name="VSTHRD010_CodeFix_Title" xml:space="preserve">
    <value>{0}의 이름을</value>
    <comment>{0} is a method name.</comment>
  </data>
  <data name="VSTHRD010_MessageFormat" xml:space="preserve">
    <value>작업 반환 메서드의 이름에 "Async" 접미사를 사용 합니다.</value>
  </data>
  <data name="VSTHRD010_Title" xml:space="preserve">
    <value>"비동기" 접미사를 사용 하 여 비동기 메서드</value>
  </data>
  <data name="VSTHRD011_MessageFormat" xml:space="preserve">
    <value>메서드 오버 로드를 TaskScheduler.Current 가정 하지 마십시오. TaskScheduler 허용 하는 오버 로드를 사용 하 고 TaskScheduler.Default (또는 다른)를 명시적으로 지정 합니다.</value>
  </data>
  <data name="VSTHRD011_Title" xml:space="preserve">
    <value>TaskScheduler.Current 가정 메서드 오버 로드를 방지</value>
  </data>
</root>